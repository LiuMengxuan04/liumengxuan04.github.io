<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Numeric Rush</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Press+Start+2P&family=Roboto:wght@700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a2e;
            font-family: 'Roboto', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; /* ÂÉèÁ¥†ÂåñÊ∏≤Êüì */
        }

        /* UI Ë¶ÜÁõñÂ±Ç */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            color: white;
            text-shadow: 2px 2px 0 #000;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 4px;
            border: 4px solid #fff;
            box-shadow: 0 4px 0 #000;
            text-align: center;
            min-width: 80px;
        }

        .stat-value {
            font-size: 20px;
            font-family: 'Press Start 2P', cursive;
            color: #ffeb3b;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 10px;
            color: #ccc;
            text-transform: uppercase;
            font-family: 'Press Start 2P', cursive;
        }

        .progress-container {
            position: absolute;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 12px;
            background: #333;
            border: 2px solid #fff;
            border-radius: 0;
            overflow: hidden;
        }

        #progressBar {
            width: 0%;
            height: 100%;
            background: #00e676;
            transition: width 0.2s linear;
        }

        /* Ë°ÄÊù°ÂÆπÂô® */
        .hp-container {
            position: absolute;
            top: 110px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 12px;
            background: #333;
            border: 2px solid #fff;
            display: flex;
        }

        #hpBar {
            width: 100%;
            height: 100%;
            background: #ff1744;
            transition: width 0.1s linear;
        }

        /* BossË°ÄÊù° (Êñ∞) */
        #bossHpContainer {
            position: absolute;
            top: 140px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 20px;
            background: #222;
            border: 3px solid #d500f9;
            display: none; /* ÈªòËÆ§ÈöêËóè */
            box-shadow: 0 0 15px #d500f9;
        }
        #bossHpBar {
            width: 100%;
            height: 100%;
            background: #d500f9;
            transition: width 0.1s linear;
        }

        /* ËèúÂçïÂ±èÂπï */
        #menuScreen, #gameOverScreen, #victoryScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(20, 20, 40, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
        }

        h1 {
            color: #fff;
            font-family: 'Black Ops One', cursive;
            font-size: 48px;
            margin: 0 0 20px 0;
            text-transform: uppercase;
            text-shadow: 4px 4px 0 #00e676;
            text-align: center;
            letter-spacing: 2px;
        }

        .btn {
            background: #ff0055;
            border: 4px solid #fff;
            padding: 15px 30px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 4px 4px 0 #000;
            transition: transform 0.1s;
            font-family: 'Press Start 2P', cursive;
            margin-top: 30px;
            text-transform: uppercase;
        }

        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 #000;
        }

        .tips {
            color: #aaa;
            margin-top: 20px;
            font-size: 12px;
            line-height: 1.8;
            text-align: center;
            max-width: 80%;
            font-family: 'Press Start 2P', cursive;
        }

        #muteBtn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #fff;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            z-index: 200;
            pointer-events: auto;
        }

        .hidden { display: none !important; }
        
        .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-4px, 0, 0); }
            20%, 80% { transform: translate3d(4px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-8px, 0, 0); }
            40%, 60% { transform: translate3d(8px, 0, 0); }
        }

        #damageOverlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: red;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
            mix-blend-mode: overlay;
        }

    </style>
</head>
<body>

    <div id="damageOverlay"></div>
    <div id="muteBtn">üîä</div>

    <canvas id="gameCanvas"></canvas>

    <div class="ui-layer">
        <div class="hud-top" style="margin-left: 50px;">
            <div class="stat-box">
                <div class="stat-value" id="scoreDisplay">0</div>
                <div class="stat-label">SCORE</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="atkDisplay">10</div>
                <div class="stat-label">POWER</div>
            </div>
        </div>
        
        <div class="progress-container">
            <div id="progressBar"></div>
        </div>
        <div class="hp-container">
            <div id="hpBar"></div>
        </div>
        <!-- Áã¨Á´ãÁöÑBOSSË°ÄÊù° -->
        <div id="bossHpContainer">
            <div id="bossHpBar"></div>
        </div>
    </div>

    <!-- ËèúÂçï -->
    <div id="menuScreen">
        <h1>Êï∞ÂÄºÁãÇÂ•î<br><span style="font-size:20px; color:#00e676; font-family:'Press Start 2P'">Numeric Rush</span></h1>
        <div class="tips">
            TAP LEFT/RIGHT TO MOVE<br><br>
            [ÁªøËâ≤] Â¢ûÂä†ÊîªÂáªÂäõ<br>
            [Á∫¢Ëâ≤] ÂáèÂ∞ëÊîªÂáªÂäõ<br>
            [BOSS] Ë∫≤ÈÅøÂºπÂπïÊîªÂáª!
        </div>
        <button class="btn" onclick="initGame()">START GAME</button>
    </div>

    <!-- Â§±Ë¥• -->
    <div id="gameOverScreen" class="hidden">
        <h1 style="color:#ff3d00; text-shadow: 4px 4px 0 #000;">GAME OVER</h1>
        <div class="tips" id="failReason">HP DEPLETED</div>
        <div class="stat-box" style="margin: 20px;">
            <div class="stat-value" id="finalScoreFail">0</div>
            <div class="stat-label">FINAL SCORE</div>
        </div>
        <button class="btn" onclick="initGame()">RETRY</button>
    </div>

    <!-- ËÉúÂà© -->
    <div id="victoryScreen" class="hidden">
        <h1 style="color:#ffd700; text-shadow: 4px 4px 0 #000;">VICTORY!</h1>
        <div class="tips">LEGENDARY RUN</div>
        <div class="stat-box" style="margin: 20px;">
            <div class="stat-value" id="finalScoreWin">0</div>
            <div class="stat-label">SCORE (x2)</div>
        </div>
        <button class="btn" onclick="initGame()">PLAY AGAIN</button>
    </div>

    <script>
        const SoundManager = {
            ctx: null,
            muted: false,
            init: function() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') this.ctx.resume();
            },
            toggleMute: function() {
                this.muted = !this.muted;
                document.getElementById('muteBtn').innerText = this.muted ? 'üîá' : 'üîä';
            },
            playTone: function(freq, type, duration, vol = 0.1, slideTo = null) {
                if (this.muted || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if (slideTo) osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            playNoise: function(duration, vol = 0.1) {
                if (this.muted || !this.ctx) return;
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                noise.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            },
            playShoot: function() { this.playTone(400, 'square', 0.1, 0.05, 100); },
            playHit: function() { this.playNoise(0.05, 0.05); },
            playCoin: function() { this.playTone(1200, 'square', 0.1, 0.05); setTimeout(() => this.playTone(1800, 'square', 0.2, 0.05), 50); },
            playPowerUp: function() { this.playTone(400, 'sine', 0.1, 0.1, 600); setTimeout(() => this.playTone(600, 'sine', 0.2, 0.1, 1200), 100); },
            playDamage: function() { this.playTone(150, 'sawtooth', 0.3, 0.2, 50); this.playNoise(0.3, 0.2); },
            playExplosion: function() { this.playNoise(0.4, 0.3); this.playTone(100, 'sawtooth', 0.4, 0.2, 10); },
            playBossShoot: function() { this.playTone(200, 'sawtooth', 0.2, 0.1, 100); }
        };

        document.getElementById('muteBtn').addEventListener('click', () => SoundManager.toggleMute());

        const CONFIG = {
            lanes: 3,
            laneWidthRatio: 1 / 3,
            playerSpeed: 18,
            baseBulletSpeed: 900,
            baseEnemySpeed: 350,
            baseItemSpeed: 400,
            bossBulletSpeed: 500, // BossÂ≠êÂºπÈÄüÂ∫¶
            totalTime: 90, 
            bossTime: 80,
            colors: {
                buff: '#00e676',
                debuff: '#ff1744',
                trap: '#9e9e9e',
                player: '#2979ff',
                bossBullet: '#ff0055', // BossÂ≠êÂºπÈ¢úËâ≤
                bgLane: 'rgba(255, 255, 255, 0.03)',
                bgLaneActive: 'rgba(255, 255, 255, 0.08)'
            }
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        let gameState = {
            status: 'menu',
            lastTime: 0,
            gameTime: 0,
            laneWidth: 0,
            lanesX: [],
            score: 0,
            shakeTimer: 0,
            
            bullets: [],
            enemyBullets: [], // BossÂ≠êÂºπ
            enemies: [],
            items: [],
            particles: [],
            floatTexts: [],

            player: {
                lane: 1,
                x: 0, y: 0, targetX: 0,
                width: 48, height: 48,
                hp: 100, maxHp: 100,
                atk: 10, atkSpeed: 2.0,
                lastShot: 0, invincibleTimer: 0, frame: 0
            },
            
            boss: null
        };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gameState.laneWidth = canvas.width / CONFIG.lanes;
            gameState.lanesX = [
                gameState.laneWidth * 0.5,
                gameState.laneWidth * 1.5,
                gameState.laneWidth * 2.5
            ];
            if(gameState.status === 'playing') gameState.player.targetX = gameState.lanesX[gameState.player.lane];
        }
        window.addEventListener('resize', resize);
        resize();

        function handleInput(x) {
            if (gameState.status !== 'playing') return;
            SoundManager.init();
            if (x < canvas.width / 2) {
                if (gameState.player.lane > 0) gameState.player.lane--;
            } else {
                if (gameState.player.lane < 2) gameState.player.lane++;
            }
        }

        canvas.addEventListener('mousedown', (e) => handleInput(e.clientX));
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(e.touches[0].clientX); }, { passive: false });
        window.addEventListener('keydown', (e) => {
            if (gameState.status !== 'playing') return;
            SoundManager.init();
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') if (gameState.player.lane > 0) gameState.player.lane--;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') if (gameState.player.lane < 2) gameState.player.lane++;
        });

        function initGame() {
            SoundManager.init();
            SoundManager.playCoin();
            ['menuScreen', 'gameOverScreen', 'victoryScreen'].forEach(id => document.getElementById(id).classList.add('hidden'));
            document.getElementById('bossHpContainer').style.display = 'none';
            
            gameState.status = 'playing';
            gameState.gameTime = 0;
            gameState.score = 0;
            gameState.bullets = [];
            gameState.enemyBullets = [];
            gameState.enemies = [];
            gameState.items = [];
            gameState.particles = [];
            gameState.floatTexts = [];
            gameState.boss = null;
            gameState.bossSpawned = false;
            gameState.shakeTimer = 0;

            gameState.player = {
                lane: 1,
                x: gameState.lanesX[1], targetX: gameState.lanesX[1],
                y: canvas.height - 150,
                width: 48, height: 48,
                hp: 100, maxHp: 100,
                atk: 10, atkSpeed: 2.0,
                lastShot: 0, invincibleTimer: 0, frame: 0
            };

            gameState.lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function triggerDamage() {
            if (gameState.player.invincibleTimer > 0) return;
            gameState.player.hp -= 30;
            gameState.player.invincibleTimer = 1.0; // ÂáèÂ∞ëÊó†ÊïåÊó∂Èó¥ÔºåÂ¢ûÂä†Á¥ßÂº†ÊÑü
            gameState.shakeTimer = 0.5;
            SoundManager.playDamage();
            const overlay = document.getElementById('damageOverlay');
            overlay.style.opacity = 0.6;
            setTimeout(() => overlay.style.opacity = 0, 100);
            if (gameState.player.hp <= 0) {
                gameState.player.hp = 0;
                gameOver("HP DEPLETED");
            }
        }

        function gameOver(reason) {
            gameState.status = 'gameover';
            document.getElementById('gameOverScreen').classList.remove('hidden');
            document.getElementById('failReason').innerText = reason;
            document.getElementById('finalScoreFail').innerText = gameState.score;
        }

        function victory() {
            gameState.status = 'victory';
            document.getElementById('victoryScreen').classList.remove('hidden');
            document.getElementById('finalScoreWin').innerText = gameState.score * 2;
        }

        // --- ÈÄªËæëÁ≥ªÁªü ---

        function spawnManager(dt) {
            if (!gameState.spawner) gameState.spawner = { timer: 0 };
            
            if (gameState.gameTime >= CONFIG.bossTime) {
                if (!gameState.boss && !gameState.bossSpawned) spawnBoss();
                gameState.bossSpawned = true;
                
                // BossÊàòÊåÅÁª≠ÁîüÊàêÈÅìÂÖ∑
                gameState.spawner.timer += dt;
                if (gameState.spawner.timer > 1.2) { 
                     spawnItem(true);
                     gameState.spawner.timer = 0;
                }
                return;
            }

            gameState.spawner.timer += dt;
            let difficulty = 1 + (gameState.gameTime / 60);
            let spawnInterval = 1.0 / difficulty; 

            if (gameState.spawner.timer > spawnInterval) {
                gameState.spawner.timer = 0;
                const rand = Math.random();
                if (rand < 0.25) spawnItem();
                else spawnEnemy(difficulty);
            }
        }

        function spawnEnemy(difficulty) {
            const lane = Math.floor(Math.random() * 3);
            let type = 'slime', hp = 4 + (difficulty * 2), speed = CONFIG.baseEnemySpeed * (1 + difficulty * 0.1), color = '#ff9100', scoreVal = 50;
            if (gameState.gameTime > 20 && Math.random() > 0.7) {
                type = 'box'; hp = 10 + (difficulty * 4); speed = CONFIG.baseEnemySpeed * 0.8; color = '#ff3d00'; scoreVal = 100;
            }
            gameState.enemies.push({
                lane, x: gameState.lanesX[lane], y: -100, width: 48, height: 48,
                type, hp: Math.floor(hp), maxHp: Math.floor(hp), speed, color, scoreVal, frame: 0
            });
        }

        function spawnItem(forceBuff = false) {
            const lane = Math.floor(Math.random() * 3);
            let type = 'buff';
            const rand = Math.random();
            if (!forceBuff) {
                if (rand < 0.6) type = 'buff'; else if (rand < 0.8) type = 'debuff'; else type = 'trap';
            }
            let value = 0, text = "", color = "", symbol = "";
            if (type === 'buff') {
                const subType = Math.random() > 0.6 ? 'atk' : 'spd';
                color = CONFIG.colors.buff;
                if (subType === 'atk') { value = Math.floor(Math.random() * 20) + 10; text = `PWR +${value}%`; symbol = '+'; } 
                else { value = 0.2; text = "SPD UP"; symbol = '‚ö°'; }
                gameState.items.push({ lane, x: gameState.lanesX[lane], y: -100, type, subType, value, text, color, symbol, speed: CONFIG.baseItemSpeed });
            } else if (type === 'debuff') {
                color = CONFIG.colors.debuff; value = -(Math.floor(Math.random() * 20) + 10); text = `PWR ${value}%`; symbol = '-';
                gameState.items.push({ lane, x: gameState.lanesX[lane], y: -100, type: 'debuff', value, text, color, symbol, speed: CONFIG.baseItemSpeed });
            } else {
                color = CONFIG.colors.trap; text = "HP -30"; symbol = '‚ò†Ô∏è';
                gameState.items.push({ lane, x: gameState.lanesX[lane], y: -100, type: 'trap', value: 0, text, color, symbol, speed: CONFIG.baseItemSpeed });
            }
        }

        function spawnBoss() {
            // ËÆ°ÁÆóDPS: ÊîªÂáªÂäõ * ÊîªÈÄü
            const currentDps = gameState.player.atk * gameState.player.atkSpeed;
            // ÁõÆÊ†áÊàòÊñóÊó∂Èïø: 40Áßí
            const targetHp = currentDps * 40;
            // ‰øùÂ∫ïHPÔºåÈò≤Ê≠¢Áé©ÂÆ∂ÊîªÂáªÂäõÂ§™‰Ωé
            const finalHp = Math.max(targetHp, 20000);

            gameState.boss = {
                x: canvas.width / 2,
                y: -200,
                width: canvas.width * 0.9, // Âç†ÊçÆÂ±èÂπï90%ÂÆΩÂ∫¶ÔºåÁ°Æ‰øù‰∏âË∑ØÈÉΩËÉΩÊâìÂà∞
                height: 200,
                hp: finalHp,
                maxHp: finalHp,
                speed: 40,
                frame: 0,
                attackTimer: 0, // ÊîªÂáªËÆ°Êó∂Âô®
                state: 'descend' // descend, idle
            };
            document.getElementById('bossHpContainer').style.display = 'block';
            addFloatText(canvas.width/2, 200, "WARNING: MEGA BOSS!!", "#d500f9", 30);
            SoundManager.playExplosion();
        }

        function spawnBossBullet(laneIndex) {
            const x = gameState.lanesX[laneIndex];
            gameState.enemyBullets.push({
                x: x,
                y: gameState.boss.y + 100,
                width: 30, height: 60,
                speed: CONFIG.bossBulletSpeed,
                color: CONFIG.colors.bossBullet
            });
            SoundManager.playBossShoot();
        }

        function createParticles(x, y, color, count = 5) {
            for(let i=0; i<count; i++) {
                gameState.particles.push({
                    x, y, vx: (Math.random() - 0.5) * 400, vy: (Math.random() - 0.5) * 400,
                    life: 0.6, color, size: Math.random() * 6 + 4
                });
            }
        }

        function addFloatText(x, y, text, color, size = 20) {
            gameState.floatTexts.push({ x, y, text, color, size, life: 1.0 });
        }

        function gameLoop(timestamp) {
            if (gameState.status !== 'playing') return;
            const dt = Math.min((timestamp - gameState.lastTime) / 1000, 0.1);
            gameState.lastTime = timestamp;
            gameState.gameTime += dt;
            gameState.player.frame++;

            if (gameState.player.invincibleTimer > 0) gameState.player.invincibleTimer -= dt;
            if (gameState.shakeTimer > 0) {
                gameState.shakeTimer -= dt;
                ctx.save();
                ctx.translate((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
            }

            document.getElementById('atkDisplay').innerText = Math.floor(gameState.player.atk);
            document.getElementById('scoreDisplay').innerText = gameState.score;
            document.getElementById('progressBar').style.width = (Math.min(gameState.gameTime / CONFIG.totalTime, 1) * 100) + '%';
            document.getElementById('hpBar').style.width = (gameState.player.hp) + '%';
            if(gameState.boss) {
                 document.getElementById('bossHpBar').style.width = (gameState.boss.hp / gameState.boss.maxHp * 100) + '%';
            }

            // Player Move
            gameState.player.targetX = gameState.lanesX[gameState.player.lane];
            gameState.player.x += (gameState.player.targetX - gameState.player.x) * CONFIG.playerSpeed * dt;

            // Player Shoot
            if (gameState.player.atk > 0) {
                gameState.player.lastShot += dt;
                if (gameState.player.lastShot >= 1 / gameState.player.atkSpeed) {
                    gameState.player.lastShot = 0;
                    const size = Math.min(8 + gameState.player.atk / 5, 30); 
                    gameState.bullets.push({
                        x: gameState.player.x, y: gameState.player.y - 40,
                        radius: size / 2, speed: CONFIG.baseBulletSpeed,
                        damage: gameState.player.atk,
                        color: gameState.player.atk > 50 ? '#ffeb3b' : '#fff'
                    });
                    SoundManager.playShoot();
                }
            }

            spawnManager(dt);

            // Entities Update
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const b = gameState.bullets[i];
                b.y -= b.speed * dt;
                if (b.y < -50) gameState.bullets.splice(i, 1);
            }

            // Enemy Bullets (Boss Attacks)
            for (let i = gameState.enemyBullets.length - 1; i >= 0; i--) {
                const eb = gameState.enemyBullets[i];
                eb.y += eb.speed * dt;
                // Collision with Player
                if (Math.abs(eb.x - gameState.player.x) < 30 && Math.abs(eb.y - gameState.player.y) < 40) {
                    triggerDamage();
                    gameState.enemyBullets.splice(i, 1);
                    continue;
                }
                if (eb.y > canvas.height + 50) gameState.enemyBullets.splice(i, 1);
            }

            for (let i = gameState.items.length - 1; i >= 0; i--) {
                const item = gameState.items[i];
                item.y += item.speed * dt;
                if (Math.abs(item.y - gameState.player.y) < 50 && Math.abs(item.x - gameState.player.x) < 30) {
                    if (item.type === 'buff') {
                        if (item.subType === 'atk') gameState.player.atk += Math.floor(gameState.player.atk * (item.value / 100));
                        if (item.subType === 'spd') gameState.player.atkSpeed = Math.min(gameState.player.atkSpeed + 0.5, 12);
                        addFloatText(gameState.player.x, gameState.player.y - 50, item.text, '#00e676', 24);
                        createParticles(gameState.player.x, gameState.player.y, '#00e676', 10);
                        SoundManager.playPowerUp();
                    } else if (item.type === 'debuff') {
                        gameState.player.atk += Math.floor(gameState.player.atk * (item.value / 100));
                        if (gameState.player.atk < 0) gameState.player.atk = 0;
                        addFloatText(gameState.player.x, gameState.player.y - 50, item.text, '#ff1744', 24);
                        createParticles(gameState.player.x, gameState.player.y, '#ff1744', 10);
                        SoundManager.playDamage();
                    } else if (item.type === 'trap') triggerDamage();
                    gameState.items.splice(i, 1);
                    continue;
                }
                if (item.y > canvas.height + 50) gameState.items.splice(i, 1);
            }

            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const e = gameState.enemies[i];
                e.y += e.speed * dt; e.frame++;
                for (let j = gameState.bullets.length - 1; j >= 0; j--) {
                    const b = gameState.bullets[j];
                    if (Math.abs(b.x - e.x) < 30 && Math.abs(b.y - e.y) < 30) {
                        e.hp -= b.damage; SoundManager.playHit(); gameState.bullets.splice(j, 1); createParticles(b.x, b.y, '#fff', 2);
                        if (e.hp <= 0) {
                            gameState.score += e.scoreVal; addFloatText(e.x, e.y, `+${e.scoreVal}`, '#ffd700', 20);
                            createParticles(e.x, e.y, e.color, 15); SoundManager.playCoin(); SoundManager.playExplosion();
                            gameState.enemies.splice(i, 1); break; 
                        }
                    }
                }
                if (e && e.hp > 0) {
                    if (Math.abs(e.y - gameState.player.y) < 40 && Math.abs(e.x - gameState.player.x) < 30) {
                        triggerDamage(); createParticles(e.x, e.y, '#fff', 10); gameState.enemies.splice(i, 1);
                    } else if (e.y > canvas.height + 50) gameState.enemies.splice(i, 1);
                }
            }

            // Boss Logic
            if (gameState.boss) {
                if (gameState.boss.y < 120) gameState.boss.y += gameState.boss.speed * dt;
                
                // ÊîªÂáªÈÄªËæë
                gameState.boss.attackTimer += dt;
                if (gameState.boss.attackTimer > 1.2) { // ÊØè1.2ÁßíÂèëÂ∞Ñ‰∏ÄÊ¨°
                    gameState.boss.attackTimer = 0;
                    // ÈöèÊú∫ÈÄâÊã©‰∏Ä‰∏™ÂÆâÂÖ®ÈÄöÈÅìÔºåÂÖ∂‰ªñÈÄöÈÅìÂèëÂ∞ÑÂ≠êÂºπ
                    const safeLane = Math.floor(Math.random() * 3);
                    for(let i=0; i<3; i++) {
                        if (i !== safeLane) spawnBossBullet(i);
                    }
                }

                // Á¢∞ÊíûÂà§ÂÆöÔºöBossÂÆΩÂ∫¶ÂæàÂ§ßÔºåÊâÄ‰ª•Áî®ËåÉÂõ¥Âà§ÂÆö
                const bossHalfW = gameState.boss.width / 2;
                const bossHalfH = gameState.boss.height / 2;
                
                for (let j = gameState.bullets.length - 1; j >= 0; j--) {
                    const b = gameState.bullets[j];
                    // Âè™Ë¶ÅÂ≠êÂºπÊâìÂú®BossÁöÑÂÆΩÂ∫¶ËåÉÂõ¥ÂÜÖÔºå‰∏îÈ´òÂ∫¶Êé•Ëß¶
                    if (b.y < gameState.boss.y + bossHalfH && b.y > gameState.boss.y - bossHalfH &&
                        b.x > gameState.boss.x - bossHalfW && b.x < gameState.boss.x + bossHalfW) {
                        gameState.boss.hp -= b.damage;
                        SoundManager.playHit();
                        createParticles(b.x, b.y, '#d500f9', 2);
                        gameState.bullets.splice(j, 1);
                        if (gameState.boss.hp <= 0) {
                            SoundManager.playCoin();
                            victory(); return;
                        }
                    }
                }
            }

            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const p = gameState.particles[i];
                p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
                if (p.life <= 0) gameState.particles.splice(i, 1);
            }
            for (let i = gameState.floatTexts.length - 1; i >= 0; i--) {
                const ft = gameState.floatTexts[i];
                ft.y -= 60 * dt; ft.life -= dt;
                if (ft.life <= 0) gameState.floatTexts.splice(i, 1);
            }

            render();
            if (gameState.shakeTimer > 0) ctx.restore();
            requestAnimationFrame(gameLoop);
        }

        function drawPixelRect(ctx, x, y, w, h, color) {
            ctx.fillStyle = color; ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
        }
        
        function drawSprite(ctx, x, y, scale, type, color, frame) {
            ctx.save(); ctx.translate(Math.floor(x), Math.floor(y)); ctx.scale(scale, scale); ctx.fillStyle = color;
            let map = [];
            if (type === 'player') {
                const bob = frame % 20 < 10 ? 0 : 1;
                map = [0,1,1,1,1,1,0,0, 1,1,1,1,1,1,1,0, 1,0,1,1,1,0,1,0, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,0,0, 1,1,1,1,1,1,1,0, 1,0,0,0,0,0,1,0, 1,0,0,0,0,0,1,0];
                if (bob) ctx.translate(0, 1);
            } else if (type === 'enemy_slime') {
                const squish = frame % 20 < 10 ? 0 : 1;
                map = [0,0,0,0,0,0,0,0, 0,0,1,1,1,0,0,0, 0,1,1,1,1,1,0,0, 1,1,0,1,0,1,1,0, 1,1,1,1,1,1,1,0, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,0,0, 0,0,0,0,0,0,0,0];
                if (squish) ctx.scale(1.1, 0.9);
            } else if (type === 'enemy_box') {
                map = [1,1,1,1,1,1,1,1, 1,0,0,1,1,0,0,1, 1,0,1,1,1,1,0,1, 1,1,1,0,0,1,1,1, 1,1,1,0,0,1,1,1, 1,1,0,1,1,0,1,1, 1,0,1,1,1,1,0,1, 1,1,1,1,1,1,1,1];
            } else if (type === 'boss') {
                // Boss sprite (ÂÆΩ‰Ωì)
                map = [
                    0,0,1,1,1,1,0,0,
                    0,1,1,1,1,1,1,0,
                    1,1,0,1,1,0,1,1,
                    1,1,1,1,1,1,1,1,
                    1,0,1,1,1,1,0,1,
                    1,1,0,0,0,0,1,1,
                    0,1,1,0,0,1,1,0,
                    0,0,1,1,1,1,0,0
                ];
            }
            for(let i=0; i<8; i++) for(let j=0; j<8; j++) if (map[i*8 + j]) ctx.fillRect(j-4, i-4, 1, 1);
            ctx.restore();
        }

        function render() {
            ctx.fillStyle = '#1a1a2e'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.lineWidth = 4;
            for(let i=0; i<CONFIG.lanes; i++) {
                const x = gameState.lanesX[i];
                ctx.strokeStyle = i === gameState.player.lane ? CONFIG.colors.bgLaneActive : CONFIG.colors.bgLane;
                ctx.beginPath(); ctx.moveTo(x - gameState.laneWidth/2, 0); ctx.lineTo(x - gameState.laneWidth/2, canvas.height); ctx.stroke();
            }

            gameState.enemies.forEach(e => {
                const type = e.type === 'box' ? 'enemy_box' : 'enemy_slime';
                drawSprite(ctx, e.x, e.y, 4, type, e.color, e.frame);
                ctx.fillStyle = 'red'; ctx.fillRect(e.x - 20, e.y - 40, 40 * (e.hp/e.maxHp), 4);
            });

            if (gameState.boss) {
                // ÁªòÂà∂Â∑®Â§ßÁöÑ Boss 
                // ‰∏∫‰∫ÜËßÜËßâÊïàÊûúÔºåÊàë‰ª¨ÁªòÂà∂3‰∏™Âπ∂ÊéíÁöÑÂÉèÁ¥†Á≤æÁÅµÔºåÊàñËÄÖÊääÂÆÉÊãâÂÆΩ
                ctx.save();
                ctx.translate(gameState.boss.x, gameState.boss.y);
                // ÁªòÂà∂‰∏Ä‰∏™Ë¶ÜÁõñÂÆΩÂ∫¶ÁöÑÂèëÂÖâËÉåÊôØ
                ctx.fillStyle = "rgba(213, 0, 249, 0.2)";
                ctx.fillRect(-gameState.boss.width/2, -gameState.boss.height/2, gameState.boss.width, gameState.boss.height);
                
                // ÁªòÂà∂Ê†∏ÂøÉ Boss ÂΩ¢Ë±° (ÊîæÂ§ß)
                ctx.restore();
                drawSprite(ctx, gameState.boss.x, gameState.boss.y, 16, 'boss', '#d500f9', Math.floor(Date.now()/100));
            }

            gameState.items.forEach(item => {
                ctx.save(); ctx.translate(item.x, item.y); ctx.shadowBlur = 10; ctx.shadowColor = item.color;
                ctx.fillStyle = item.color; ctx.fillRect(-15, -15, 30, 30);
                ctx.fillStyle = '#000'; ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(item.symbol, 0, 0);
                ctx.restore();
            });

            gameState.bullets.forEach(b => {
                ctx.fillStyle = b.color; ctx.beginPath(); ctx.rect(b.x - b.radius/2, b.y - b.radius*2, b.radius, b.radius*2); ctx.fill();
            });

            // ÁªòÂà∂ Boss Â≠êÂºπ
            gameState.enemyBullets.forEach(eb => {
                ctx.save();
                ctx.translate(eb.x, eb.y);
                ctx.fillStyle = eb.color;
                ctx.shadowBlur = 10; ctx.shadowColor = 'red';
                // ÁªòÂà∂Â∞ñÂà∫ÂΩ¢Áä∂
                ctx.beginPath();
                ctx.moveTo(0, 20); ctx.lineTo(10, -20); ctx.lineTo(-10, -20);
                ctx.fill();
                ctx.restore();
            });

            gameState.particles.forEach(p => {
                ctx.save(); ctx.globalAlpha = Math.max(0, p.life / 0.6); drawPixelRect(ctx, p.x, p.y, p.size, p.size, p.color); ctx.restore();
            });

            if (gameState.player.invincibleTimer <= 0 || Math.floor(Date.now() / 50) % 2 === 0) {
                drawSprite(ctx, gameState.player.x, gameState.player.y, 5, 'player', '#2979ff', gameState.player.frame);
            }

            gameState.floatTexts.forEach(ft => {
                ctx.save(); ctx.globalAlpha = Math.max(0, ft.life); ctx.fillStyle = ft.color; ctx.font = `${ft.size}px 'Press Start 2P'`;
                ctx.fillText(ft.text, ft.x - (ft.text.length * ft.size * 0.4), ft.y); ctx.restore();
            });
        }
    </script>
</body>
</html>